{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"肥肠抱歉，出错了","date":"2019-06-27T14:43:00.207Z","updated":"2019-06-27T14:43:00.178Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"Hello, World","date":"2019-06-26T16:00:00.000Z","updated":"2019-06-27T14:10:34.287Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"没人会看的东西，随便介绍下 twitter ID 后面跟的 emoji 是什么吧 🐬：白海豚，组长，带我真正入坑vtuber的女人（電脳少女シロ@SIROyoutuber ） 🥕：两个喜欢中国的猴姬（田中ヒメ@HimeTanaka_HH &amp; 鈴木ヒナ@HinaSuzuki_HH） 🐀*： vtuber开创者之一，激励人心的虚拟梦想守护者（のらきゃっと@VR_Girl_NoraCat） 💜*：成于资本，败于资本。怀念我的杂鱼后辈（アズマリム@azuma_lim） 🐇*：彩虹社的唯一清楚，超可爱的爱丽丝(16/2)（物述有栖@AliceMononobe） 🌽：hololive少主，仅凭一人之力拯救了一个公司的女人，进军中国的先锋军（白上フブキ@shirakamifubuki） 注：标有*的代表由于本人未定义特有emoji，或本人定义的emoji过长，所用emoji非官方承认的emoji表达方式，而是基于角色性格二次创作得来"}],"posts":[{"title":"P1019 单词接龙","slug":"P1019 单词接龙","date":"2019-06-25T16:00:00.000Z","updated":"2019-06-27T12:39:41.866Z","comments":true,"path":"2019/06/26/P1019 单词接龙/","link":"","permalink":"http://yoursite.com/2019/06/26/P1019 单词接龙/","excerpt":"题目来源：洛谷P1019 单词接龙 调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了… 这个程序一个问题就是循环根本就不会吧dict全循环一遍，那可能就是初始化出了问题： m=pointer 的位置，当时记得应该写一个副本 m 代替 pointer 被改变，但是写着写着忘了 m 具体应该在哪被初始化了，问题就出现在这 回溯的状态：一定要明确回溯应当回溯到具体那个状态，是ans_temp已经被改变的状态吗？还是未改变的状态？本题中是ans_temp未改变的状态","text":"题目来源：洛谷P1019 单词接龙 调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了… 这个程序一个问题就是循环根本就不会吧dict全循环一遍，那可能就是初始化出了问题： m=pointer 的位置，当时记得应该写一个副本 m 代替 pointer 被改变，但是写着写着忘了 m 具体应该在哪被初始化了，问题就出现在这 回溯的状态：一定要明确回溯应当回溯到具体那个状态，是ans_temp已经被改变的状态吗？还是未改变的状态？本题中是ans_temp未改变的状态 我的解与标解 跟我的做法一样，区别只是标解用for循环枚举j而不是跟我一样用直接用dfs函数 下面是我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;char dict[21][30],ans[500]; int n,vis[21],ans_max=0,ans_temp=0;void dfs(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0][0];///开头的字母 dfs(0,0); cout&lt;&lt;ans_max; return 0;&#125;void dfs(int word,int pointer)&#123; if(pointer&lt;strlen(dict[word]))&#123; ans_temp++; int ans_mark=ans_temp; ans_max=max(ans_max,ans_temp); dfs(word,pointer+1);///这句话以上是将本单词中的下一个字母加入答案字符串中，以下是将查看以这个字母为基准，能不能接上其他单词的龙 ans_temp=ans_mark; &#125; int m; for(int i=1;i&lt;=n;i++)&#123;///枚举n个词中哪个词的首字母可以和现在字符串的最后一个相同 if(vis[i]&gt;0)&#123; int j=0; ///!!! m=pointer; ///!!!其他人的做法是直接枚举单词 word 中的所有字母，不像我是通过 dfs(word,pointer+1)来枚举，所以不需要考虑pointer如何如何，我们这里如果对 pointer 后面的字母(pointer+1,pointer+2,...)一个个进行比对，必然会改变pointer的值，所以用了一个副本 m 进行比对，保证pointer值不变 if(dict[word][m]==dict[i][j])&#123;///如果头一个字母相同 bool flag=true; while(m&lt;strlen(dict[word]))&#123;///一直比对到最后一个字母，并且这里判断了“相邻的两部分不能存在包含关系”这一条件 if(dict[word][m]!=dict[i][j]) flag=false; m++; j++; &#125; if(flag)&#123;///如果每个字母都一样 ///!!! int ans_mark=ans_temp;///记录一下现在的长度，因为再进行其他的dfs，ans_temp会被更新 ans_temp+=j-1;///答案字符串的长度就可以加上新加入的单词的长度 ///!!!注意这个地方这两句话应该是先记录 ans_temp 再更新 ans_temp ，因为我们最后回溯的时候是要回溯到没有接龙接上当前单词的状态，所以应该是先记录，后更新 ans_max=max(ans_max,ans_temp); vis[i]--; dfs(i,j); vis[i]++; ans_temp=ans_mark;///把ans_temp更新回来 &#125; &#125; &#125; &#125;&#125; 先预处理得到两两单词间的最短重合部分，然后搜索得到答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;string dict[31]; int ans_now=1,ans_max=0,n,vis[31],overlap[31][31];///这个地方把 ans_now 设为1，是因为第一个开头的字母不会被算在长度内，为了把这个开头的字母算进去，ans_now 从1开始int find_overlap(string,string);///寻找两个单词的最小重合部分void dfs(int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0];///开头的字母 memset(overlap,0,sizeof(overlap)); for(int i=0;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) overlap[i][j]=find_overlap(dict[i],dict[j]); dfs(0); cout&lt;&lt;ans_max; return 0;&#125;int find_overlap(string a, string b)///其中，a是将要被别人接上去的字符串，b是想要接上去的字符串&#123; for(int i=a.size()-1;i&gt;=0;i--)&#123;///倒序寻找最小重合部分的大小 int ja=i,jb=0; bool flag=true; while(ja&lt;a.size())&#123;///正序看看这个部分是否重合 if(a[ja]!=b[jb]) &#123;flag=false; break;&#125; ja++; jb++; &#125; if(flag)&#123; int ans_overlap=a.size()-i; ///得到重叠部分的大小 if(ans_overlap!=a.size()&amp;&amp;ans_overlap!=b.size()) return ans_overlap; ///判断重叠部分是不是包含部分，如果不是就返回答案 else if(a.size()==1) return ans_overlap; ///如果是开头的字母(cin&gt;&gt;dict[0])，永远有 ans_overlap==a.size()==0 那么不管ans_overlap!=a.size()是否成立，我们都要返回答案 else return 0;///其他的情况下，重叠部分是包含部分，不能接龙，所以返回0 &#125; &#125; return 0;///没找到重叠部分&#125;void dfs(int word)&#123; for(int i=1;i&lt;=n;i++)&#123; if(overlap[word][i]&gt;0 &amp;&amp; vis[i]&gt;0)&#123; ans_now+=dict[i].size()-overlap[word][i];///接上的字符串的长度 ans_max=max(ans_max,ans_now); vis[i]--; dfs(i); vis[i]++; ans_now-=dict[i].size()-overlap[word][i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P1101 单词方阵","slug":"P1101 单词方阵","date":"2019-06-16T16:00:00.000Z","updated":"2019-06-27T12:38:11.330Z","comments":true,"path":"2019/06/17/P1101 单词方阵/","link":"","permalink":"http://yoursite.com/2019/06/17/P1101 单词方阵/","excerpt":"题目来源：洛谷P1101 单词方阵 dir 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个dir[i]来判定哪一个方向符合条件就行了","text":"题目来源：洛谷P1101 单词方阵 dir 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个dir[i]来判定哪一个方向符合条件就行了 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;char matrix[103][103], yizhong[8]=\"yizhong\"; bool mark[103][103];/// matrix 存储每个位置的字母，yizhong 存储我们要找的字符串 \"yizhong\"，mark存储这个位置符不符合要求，最后要不要被变成 \"*\" 输出int dir[8][2]=&#123;&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;;/// dir[8] 存储了8个方向，dir[i][0] 是x轴坐标，dir[i][1] 是y轴坐标void dfs(int,int); /// 这个题虽然放在dfs里面但是因为这个字符串的方向是固定的，不会拐弯抹角，所以好像和dfs没什么关系int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;matrix[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dfs(i,j); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(mark[i][j]) cout&lt;&lt;matrix[i][j]; else cout&lt;&lt;\"*\"; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void dfs(int x, int y)&#123; for(int i=0;i&lt;8;i++)&#123; ///对于任意一个点，我们都看看它周围八个方向各自符不符合条件 int j=0;bool flag=true; while(j&lt;7)&#123; ///分别检视每一个字符 与 yizhong 是否匹配 if(matrix[x+j*dir[i][0]][y+j*dir[i][1]] != yizhong[j])&#123; ///非常精髓 flag=false; break; /// 不匹配，flag=false &#125; j++; &#125; if(flag)&#123; ///匹配的话就记录下来它们是符合要求的，最后直接输出当前位置的字符 for(int j=0;j&lt;7;j++) mark[x+j*dir[i][0]][y+j*dir[i][1]]=true; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P1219 八皇后","slug":"P1219 八皇后","date":"2019-06-15T16:00:00.000Z","updated":"2019-06-27T12:35:50.676Z","comments":true,"path":"2019/06/16/P1219 八皇后/","link":"","permalink":"http://yoursite.com/2019/06/16/P1219 八皇后/","excerpt":"题目来源：洛谷P1219 八皇后 我的解法自己的程序出现的几个问题： 对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的 不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子","text":"题目来源：洛谷P1219 八皇后 我的解法自己的程序出现的几个问题： 对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的 不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子 注意初始化的部分，一开始就是把循环语句里写成了 NE_SW[i]=true; NE_SW[i+1]=true 导致了错误而且一直没检查出来 最后那个存储 solution 的地方还是有问题，如果找到了某一行的一个解并且继续向下搜寻这一行的其他解的话，会出现不存储前面几行棋子位置的问题，没想到解决方法只能在输出的地方做了些操作 大部分标解中dfs只有一个参数就是行数x然后对于每个x进行for循环枚举纵坐标y，我这样的做法也可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;bool board[14][14],col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans,solution[3][15];bool flag(int, int);void dfs(int, int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125;/// 这个地方初始化一定要注意 dfs(1,1); for(int i=0;i&lt;3;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(solution[i][j]==0) solution[i][j]=solution[i-1][j]; cout&lt;&lt;solution[i][j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;ans;&#125;bool flag(int x,int y)///判定这个点能不能放棋子&#123; if(col[x]&amp;&amp;line[y])&#123;if(NE_SW[x+y-1])&#123; if( y&lt;=x &amp;&amp; NW_SE[n-int(abs(x-y))] ) return true; else if( y&gt;x &amp;&amp; NW_SE[n+int(abs(x-y))] ) return true; //cout&lt;&lt;\"最后一个对角线出了问题\"&lt;&lt;endl; &#125;//cout&lt;&lt;\"第一个对角线出了问题\"&lt;&lt;endl; &#125; //cout&lt;&lt;\"x,y有问题\"&lt;&lt;endl; return false;&#125;void dfs(int x,int y)&#123; ///cout&lt;&lt;\"function called at\"&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; if(flag(x,y))&#123; //if(x==n) ans++; if(ans&lt;=3) solution[ans][x]=y; ///cout&lt;&lt;endl&lt;&lt;\"one unit placed at\"&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl&lt;&lt;endl; col[x]=false; line[y]=false; if(y&lt;=7-x) NE_SW[x+y-1]=false; ///左上角部分的 右上-左下对角线 else NE_SW[x+y-1]=false; /// 右下角部分的 右上-左下对角线 if(y&lt;=x) NW_SE[n-int(abs(x-y))]=false; ///右上角部分的 左上-右下对角线 else NW_SE[n+int(abs(x-y))]=false; ///左下角部分 左上-右下对角线 if(x==n) &#123;ans++;&#125; ///cout&lt;&lt;\"-------------\"&lt;&lt;endl&lt;&lt;\"one solution found, total solution is now \"&lt;&lt;ans&lt;&lt;endl&lt;&lt;\"-------------\"&lt;&lt;endl;&#125; else dfs(x+1,1); col[x]=true; line[y]=true; if(y&lt;=7-x) NE_SW[x+y-1]=true; ///左上角部分的 右上-左下对角线 else NE_SW[x+y-1]=true; /// 右下角部分的 右上-左下对角线 if(y&lt;=x) NW_SE[n-int(abs(x-y))]=true; ///右上角部分的 左上-右下对角线 else NW_SE[n+int(abs(x-y))]=true; ///左下角部分 左上-右下对角线 ///cout&lt;&lt;\"value changed back at\"&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; &#125; if(y&lt;n) dfs(x,y+1);&#125; 更可读的代码以及问题优化 优化了对角线的表达 优化了答案位置的记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;bool col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans=0,solution[14]; /// col[x] line[y]/// NE_SW 右上向左下方向的对角线，从左上角(1,1)为第一条，第二条是(2,1)-(1,2)/// NW_SE 左上到右下方向的对角线，从右上角(1,n)为第一条，第二条是(n-1,1)-(n,2)void dfs(int,int);bool flag(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125;bool flag(int x,int y)&#123; return col[x]&amp;&amp;line[y]&amp;&amp;NE_SW[x+y]&amp;&amp;NW_SE[n+y-x];&#125;void dfs(int x,int y)&#123; if(flag(x,y))&#123; solution[x]=y;///注意这个地方特别精髓，因为如果我们每个答案都开新的一行数组记录的话有可能会出现上面问题4说的情况，所以我们只需要每次覆盖记录就好了，反正x永远是按从上到下的顺序来的 //col[x]=false; line[y]=false; NE_SW[x+y]=false; NW_SE[n+y-x]=false; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; ///注意 !col[x] 只是表达 col[x] 取反的一个值，只有 col[x]=!col[x] 才能给原波尔值赋值为它的反 if(x==n)&#123;///最后一行也被填好了，我们得到一个解 ans++; if(ans&lt;=3)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;solution[i]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; &#125; else dfs(x+1,1);///还不到最后一行的话就接着去找下一行 ///回溯：拿走刚刚放下的棋子 //col[x]=true; line[y]=true; NE_SW[x+y]=true; NW_SE[n+y-x]=true; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; &#125; ///如果这个位置不符合条件(flag(x,y)==false)/这个位置符合条件的情况已经被全部枚举了(flag(x,y)==true) 那么我们就可以去找本行的下一个位置是否满足条件 if(y&lt;n) dfs(x,y+1);&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P1031 均分纸牌","slug":"P1031 均分纸牌","date":"2019-06-03T16:00:00.000Z","updated":"2019-06-27T12:40:49.788Z","comments":true,"path":"2019/06/04/P1031 均分纸牌/","link":"","permalink":"http://yoursite.com/2019/06/04/P1031 均分纸牌/","excerpt":"题目来源：洛谷P1031 均分纸牌 标解注意本题中平均数的运用 首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。","text":"题目来源：洛谷P1031 均分纸牌 标解注意本题中平均数的运用 首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。 1234567891011#include &lt;iostream&gt; using namespace std; int main() &#123; int a,p=0,js=0; cin &gt;&gt;a;int q[a]; for (int y=0;y&lt;a;y++)&#123;cin &gt;&gt;q[y]; p+=q[y];&#125; p/=a; for (int y=0;y&lt;a;y++)q[y]-=p; for (int y=0;y&lt;a;y++) &#123;if (q[y]==0)continue; q[y+1]+=q[y]; js++; &#125; cout &lt;&lt;js; return 0;&#125; 我的解法1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int sum=0,card[103],num,mean,no_count=0; cin&gt;&gt;num; for(int i=1;i&lt;=num;i++) &#123;cin&gt;&gt;card[i]; sum+=card[i];&#125; mean=sum/num; int pointer=0,local_sum=0; for(int i=1;i&lt;=num;i++)&#123; local_sum+=card[i]; pointer++;///我的思路是记录有没有一个 local_max==local_sum，如果有 local_sum，即pointer所指的那一堆，之前的就全部排好了，不需要再操心了 if(pointer==1 &amp;&amp; card[i]==mean) &#123;pointer=1; no_count++;&#125; ///直接等于平均数的堆要拿出来特殊讨论，因为他们只有跟在已经排好序的堆后面的时候才不需要再经过一次移动，而前面的堆已经排好序的标志就是 pointer==1，这种情况下我们可以少移动一个，并且重新设置 pointer==1 代表前面的堆都有序 if(local_sum==pointer*mean &amp;&amp; pointer!=1)&#123; /// local_sum==pointer*mean 此时我们找到一个堆，可以使前面的所有堆获得符合要求的解，并且他只需要向别人输送牌，自己不需要接受，所以有一个 no_count++ /// pointer!=1 这是 local_sum 就是他本身，必然相等 no_count++; pointer=0; local_sum=0; &#125; &#125; cout&lt;&lt;num-no_count;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P2678 跳石头","slug":"P2678 跳石头","date":"2019-06-02T16:00:00.000Z","updated":"2019-06-27T12:27:21.150Z","comments":true,"path":"2019/06/03/P2678 跳石头/","link":"","permalink":"http://yoursite.com/2019/06/03/P2678 跳石头/","excerpt":"题目来源：洛谷P2678 跳石头 这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 贪心+二分查找 的方法来做 二分答案/二分查找有序（单调）的，有界的就可以用二分法查找。","text":"题目来源：洛谷P2678 跳石头 这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 贪心+二分查找 的方法来做 二分答案/二分查找有序（单调）的，有界的就可以用二分法查找。 有界：对于本题，我们可以发现，这个所谓的最短跳跃距离显然不能超过一个范围（跳一次从头跳到尾）。也就是说，答案是有一个确定的范围限制的（开头到结尾的距离内），我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行，这实际上是一种倒推 二分：那么如何确保我们可以最快的找到答案呢？二分是最好选择 单调：二分的前提条件是什么？是答案区间是整体有序的。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。最优解一定可行，但可行解不一定最优。 我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x’(x’&lt;x)都是可行解。 并且，如果有一个数y是非法解，那么一般的，所有的y’(y’&gt;y)都是非法解。 总结来说，可以使用二分查找的条件：解的上下界确定(l=0,r=L),可以写出判断条件(f(x)&lt;=m),解具有区间单调性(在某个值之前条件都成立，之后都不成立) 本题和 P2855 River Hopscotch 是同一道题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int rocks[50003],ending,num,removed,result;void finding(int,int);int main()&#123; cin&gt;&gt;ending&gt;&gt;num&gt;&gt;removed; for(int i=1;i&lt;=num;i++) cin&gt;&gt;rocks[i]; rocks[0]=0; rocks[num+1]=ending; sort(rocks+1,rocks+num+1); finding(0,ending); cout&lt;&lt;result; return 0;&#125;void finding(int m, int n)&#123; int mid=(m+n)/2, removing=0; int now=0,pointer=0;///now 表示我们现在所在的位置，pointer 表示下一个可以跳到的位置 while(pointer&lt;num)&#123;///人家这个方法直接一步子迈过去了，根本不需要记录哪个石头被拿掉了，或者判定一个原本有石头的地方被没被拿掉，毕竟题目本身就叫跳石头，为什么要一个个石头看呢，直接跳不就好了 pointer++; if(rocks[pointer]-rocks[now]&lt;mid)///我们认为mid是最短跳跃距离，如果有某种情况使得跳跃距离比这个最短的还短，我们就需要拿走这块石头来增大这个地方的跳跃距离，使其大于最短跳跃距离 removing++; else//如果比最短距离长的话，我们就可以跳过去 now=pointer; &#125; if(m&lt;=n)&#123; ///这个地方我写 m&lt;n 或者 m&lt;=n 有区别吗？我的m到最后的时候只能通过mid+1这一种方式更新，+1又不影响/2以后mid的值，所以这两个判定不是一样的吗？ ///确实判定的时候没什么区别，最后都会更新到m=4 n=4 mid=4，但是 m&lt;n 运行到 m=4 n=4 mid=4 会发现 m!&lt;n 所以不会更新 result if(removing&gt;removed) finding(m,mid-1); ///如果我们以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案是不合法的，并且所有大于mid的都不合法（越大于mid移动的石块只会越来越多），所以减少 最小移动距离 使得我们不要移动那么多石块 else if(removing&lt;=removed) &#123; result=mid; finding(mid+1,n);&#125; ///如果以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案合法，但是因为我们要寻找最大的最小值，所以增大 最小距离 看看有没有更优的解 &#125;&#125;/*25 5 2 2111417 21*/ 二分查找模板非递归形式的二分查找模板 123456789101112int l=1,r=ll;/// 1 是答案的最小值，ll是答案的最大值 while(l&lt;=r) &#123; ///当左右边界重合的时候就是答案，退出循环 int mid=(l+r)&gt;&gt;1,q=check(mid);//“&gt;&gt;1”相当于“/2” if(check) ///当该距离满足条件的时候 &#123; ///去寻找右半部分，看看还有没有符合条件的更大的值 ll=mid+1;///ll上mid右边，找右半部分 ans=mid;///记录答案（更新中） &#125; else l=mid+1;///若这个值不满足，就找左部分&#125; 下面是一个二分查找的样例 P1824 Aggressive Cows12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int stall[100005],cow_num,stall_num,ans;void finding(int,int);int main()&#123; cin&gt;&gt;stall_num&gt;&gt;cow_num; for(int i=1;i&lt;=stall_num;i++) cin&gt;&gt;stall[i]; sort(stall+1,stall+stall_num+1); finding(1,stall[stall_num]); cout&lt;&lt;ans; return 0;&#125;void finding(int m, int n)//看到一个符合要求的就填进去，最后看填进去的cow和一共有的是多是少&#123; int mid=(m+n)/2,now=1,pointer=1,cow_mid=1;///cow_mid 从1开始，如果从0开始实际上算的是间距，n+1才是牛的数量 while(pointer&lt;stall_num)&#123; pointer++; if(stall[pointer]-stall[now]&gt;=mid)&#123;///这里注意是 &gt;= 只要比最短的距离(mid)大，我们就可以放一头奶牛在这里 cow_mid++; now=pointer;&#125; &#125; if(m&lt;=n)&#123; if(cow_mid&gt;=cow_num) &#123;ans=mid; finding(mid+1,n);&#125; ///如果这次放的比我们需要放的多，说明我们的最短间距太小了，所以要增大最短间距 else finding(m,mid-1); &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P1090 合并果子","slug":"P1090 合并果子","date":"2019-05-29T16:00:00.000Z","updated":"2019-06-27T12:31:58.850Z","comments":true,"path":"2019/05/30/P1090 合并果子/","link":"","permalink":"http://yoursite.com/2019/05/30/P1090 合并果子/","excerpt":"题目来源： 洛谷P1090 合并果子 一维数组做法本题是一个简单的 Huffman树。Huffman编码 在 UTF-8 &amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度 这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快","text":"题目来源： 洛谷P1090 合并果子 一维数组做法本题是一个简单的 Huffman树。Huffman编码 在 UTF-8 &amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度 这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,berry[10005];long long ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;berry[i]; sort(berry+1,berry+1+n); for(int i=1;i&lt;=n-1;i++)&#123; berry[i+1]=berry[i]+berry[i+1];///计算每个果堆的重量 ans+=berry[i+1];///答案是每次搬的果堆的重量之和 if(berry[i+1]&gt;berry[i+2])&#123;///解决前两个数之和大于第三/四个数的情况（比如有 1 1 1 1）最优解为4而不是7 for(int j=i+1;j&lt;=n-1;j++)&#123; if(berry[j]&gt;berry[j+1]) swap(berry[j],berry[j+1]);///线性排序 &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 归并做法 据说是离散化算法 就是先把原本的从小到大排序排好。然后用两个队列，一个是存储原本的，另一个是存储合成的（由于原本的是从小到大所有新开的也是从小到大）。然后在两个队列的头取最小的，执行两次然后把这两个合并加入第二个队列中。 然后由于输入： (1≤ai≤20000)(1≤ai≤20000)(1≤ai≤20000) ，所以用桶排序就可以 O(n)O(n)O(n) 时间复杂度 要义是储存原本果堆的a1是按顺序排列的，所以存储两两合成的新果堆的a2也是按顺序排列的。取这两个果堆序列中最小的两个果堆，必定获得这一步能获得的最小的果堆。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int k,x,num,n1,n2,a1[30001],a2[30001],t[20001],w,sum;int main()&#123; scanf(\"%d\",&amp;num); memset(a1,127/3,sizeof(a1)); memset(a2,127/3,sizeof(a2)); for (int i=1;i&lt;=num;i++) &#123; scanf(\"%d\",&amp;x); t[x]++;//桶 &#125; for (int i=1;i&lt;=20000;i++) &#123; while (t[i])//通排序 &#123; t[i]--; a1[++n1]=i; &#125; &#125; int i=1,j=1; k=1; while (k&lt;num) &#123; if (a1[i]&lt;a2[j])//取最小值 &#123; w=a1[i]; i++; &#125; else &#123; w=a2[j]; j++; &#125; if (a1[i]&lt;a2[j])//取第二次 &#123; w+=a1[i]; i++; &#125; else &#123; w+=a2[j]; j++; &#125; a2[++n2]=w;//加入第二个队列 k++;//计算合并次数 sum+=w;//计算价值 &#125; printf(\"%d\",sum);&#125; 二叉（小根）堆s 代表 son, p 代表 parent, size 代表整个二叉堆中存储的数据数量 完美二叉树, 完全二叉树和完满二叉树的区分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000+10;int n,heap[maxn],size=0;void up(int p) //二叉小根堆向上调整（子节点小于父节点就调整）&#123; while(p&gt;1) &#123; if(heap[p]&lt;heap[p/2]) &#123; swap(heap[p],heap[p/2]); p/=2; &#125; else break; &#125;&#125;void insert(int val) //二叉堆插入，新元素放在堆底，向上调整&#123; heap[++size]=val; up(size);&#125;void down(int p) //二叉小根堆向下调整&#123; int s=p*2; while(s&lt;=size) &#123; //下面这句话是从左右儿子中选一个更小的做交换 if(s&lt;size&amp;&amp;heap[s+1]&lt;heap[s]) s++; if(heap[s]&lt;heap[p]) &#123; swap(heap[s],heap[p]); p=s; s=p*2; &#125; else break; &#125;&#125;void extract() //二叉堆删除堆顶&#123; heap[1]=heap[size--]; //将堆底移至堆顶，向下调整 down(1);&#125;int gettop() //返回堆顶的值&#123; return heap[1];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; int a; cin&gt;&gt;a; insert(a); //建立二叉堆 &#125; long long ans=0; //其实这里不会越界，但好像原题数据是3万 while(size&gt;=2) //如果还可合并 &#123; int top1=gettop(); //取出堆顶（堆中最小值）后删除堆顶 extract(); int top2=gettop(); //同上 extract(); ans+=(top1+top2); insert(top1+top2); //将两数之和加入二叉堆，重复运算 &#125; cout&lt;&lt;ans&lt;&lt;endl; //输出答案 return 0;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"P1309 瑞士轮","slug":"P1309 瑞士轮","date":"2019-05-29T16:00:00.000Z","updated":"2019-06-27T12:26:55.045Z","comments":true,"path":"2019/05/30/P1309 瑞士轮/","link":"","permalink":"http://yoursite.com/2019/05/30/P1309 瑞士轮/","excerpt":"题目来源：洛谷P1309 瑞士轮 胜者组和败者组分别是有序的，使用 mergesort 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 quicksort，则默认整个数据是无序的，对每个数据都重新排序所以会超时","text":"题目来源：洛谷P1309 瑞士轮 胜者组和败者组分别是有序的，使用 mergesort 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 quicksort，则默认整个数据是无序的，对每个数据都重新排序所以会超时 一种可以替代结构体的方法：排名的时候我们可以只对每个选手的序号进行排序，这样做既可以保证我们有各个人的排序，又可以保证他们的成绩和实力得到记录（序号对应着成绩和实力，在对序号根据实力排序的同时，每个序号对应的成绩和实力的顺序是不变的） *sort* 函数中 *cmp* 的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int num,round,inquiry,score[200005],power[200005],No[200005],winner[100005],loser[100005];///其中，No里每个下标代表选手的排名，power &amp; score 的下标代表选手的序号bool cmp(int, int);void mergesort();void compete();int main()&#123; cin&gt;&gt;num&gt;&gt;round&gt;&gt;inquiry; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;score[i]; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;power[i]; for(int i=1;i&lt;=2*num;i++) No[i]=i; //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;\" \"&lt;&lt;score[i]&lt;&lt;endl; sort(No+1,No+1+2*num,cmp); //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;\" \"&lt;&lt;score[i]&lt;&lt;endl; for(int i=1;i&lt;=round;i++) &#123; compete(); mergesort(); &#125; cout&lt;&lt;No[inquiry]; //while(true); return 0;&#125;bool cmp(int m, int n)&#123; ///cmp函数使用范例 if(score[m]==score[n]) return m&lt;n; else return score[m]&gt;score[n];&#125;void compete()&#123; for(int i=1;i&lt;=2*num;i=i+2) &#123; if(power[No[i]]&gt;power[No[i+1]]) &#123; score[No[i]]++; winner[i/2+1]=No[i]; loser[i/2+1]=No[i+1]; &#125; else if(power[No[i]]&lt;power[No[i+1]]) &#123; score[No[i+1]]++; winner[i/2+1]=No[i+1]; loser[i/2+1]=No[i]; &#125; &#125; /*cout&lt;&lt;\"compete\"&lt;&lt;endl; for(int i=1;i&lt;=num;i++) cout&lt;&lt;winner[i]&lt;&lt;\" \"&lt;&lt;loser[i]&lt;&lt;endl; cout&lt;&lt;endl;*/&#125;void mergesort()&#123; int i=1,j=1; while(i&lt;=num &amp;&amp; j&lt;=num) &#123; //if(score[winner[i]]&gt;score[loser[j]]) if(cmp(winner[i],loser[j])) ///完全无法理解这个地方只写一个cmp是怎么过的，难道不会有位于后面的相等score项实际比前面的相等score项序号更小这种情况吗 &#123; No[i+j-1]=winner[i]; i++; &#125; //else if(score[loser[j]]&gt;score[winner[i]]) else &#123; No[i+j-1]=loser[j]; j++; &#125; /*else if(score[loser[j]]==score[winner[i]]) &#123; int k=0,temp[200005]; while(score[winner[i]]==score[winner[i+1]]) temp[++k]=winner[i++]; while(score[loser[j]]==score[loser[j]]) temp[++k]=loser[j++]; sort(temp,temp+k); for(int a=1;a&lt;=k;a++) No[a+i+j-1]=temp[a]; &#125;*/ &#125; while(i&lt;=num) &#123; No[i+num]=winner[i]; i++; &#125; while(j&lt;=num) &#123; No[j+num]=loser[j]; j++; &#125; /*cout&lt;&lt;\"mergesort\"; for(int i=1;i&lt;=num*2;i++) cout&lt;&lt;No[i]&lt;&lt;\" \"; cout&lt;&lt;endl;*/&#125;/*2 4 17 6 6 710 5 20 15*/","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"Introduction to Git Command","slug":"Intro-to-Git-Command","date":"2019-02-09T16:00:00.000Z","updated":"2019-06-27T02:35:37.709Z","comments":true,"path":"2019/02/10/Intro-to-Git-Command/","link":"","permalink":"http://yoursite.com/2019/02/10/Intro-to-Git-Command/","excerpt":"Creating repository git init: creat a repository git add File_Name: add “File_Name” to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made","text":"Creating repository git init: creat a repository git add File_Name: add “File_Name” to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made Way-back Machine git status: tell you which files have been changed git diff: check what content exactly has been changed in each file Time Travelling commitID: git uses commit ID, a hex number calculated by SHA1 to record your commit history HEAD: HEAD is the current version, HEAD^ is the previous, HEAD^^ is the one before the previous, HEAD~100 is the last 100. git log: check the commit history git reflog: check the command history git reset --hard CommitID : Going back to the “Commit ID” version (e.g. git reset --hard HEAD^ : going back to the previous version) When you go back, the “future version” will no longer appear in “git log“. However, you can use “git reflog“ to trace “commit ID” from the future Undo Changes messed up with working directory: use git checkout -- File_Name to discard changes in working directory and make “File_Name” to go back to the latest “committed” or “added” version messed up with working directory and added it to stage: use git reset HEAD File_Name to discard changes in stage but keep “File_Name” in working directory changed, therefore going back to situation 1 committed the mess to master branch: use the Time Traveling technique in the previous section Deleting FilesIf you want to delete files that are already committed to the master branch: delete the file in working directory: rm File_Name delete the file from git / restore the file delete the file from git: git rm File_Name &amp; git commit restore the file: git checkout -- File_Name Managing BranchCreating and Deleting Branch 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; Solving Conflicts","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-02-08T16:00:00.000Z","updated":"2019-06-26T15:29:59.539Z","comments":true,"path":"2019/02/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}