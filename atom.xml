<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-27T12:39:41.866Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P1019 单词接龙</title>
    <link href="http://yoursite.com/2019/06/26/P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://yoursite.com/2019/06/26/P1019 单词接龙/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-06-27T12:39:41.866Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P1019" target="_blank" rel="noopener">洛谷P1019 单词接龙</a></p><hr><p>调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了…</p><ol><li>这个程序一个问题就是循环根本就不会吧<code>dict</code>全循环一遍，那可能就是初始化出了问题： <code>m=pointer</code> 的位置，当时记得应该写一个副本 <code>m</code> 代替 <code>pointer</code> 被改变，但是写着写着忘了 <code>m</code> 具体应该在哪被初始化了，问题就出现在这</li><li>回溯的状态：一定要明确回溯应当回溯到具体那个状态，是<code>ans_temp</code>已经被改变的状态吗？还是未改变的状态？本题中是<code>ans_temp</code>未改变的状态</li></ol><a id="more"></a><h2 id="我的解与标解"><a href="#我的解与标解" class="headerlink" title="我的解与标解"></a>我的解与标解</h2><ol><li>跟我的做法一样，区别只是标解用<code>for</code>循环枚举<code>j</code>而不是跟我一样用直接用<code>dfs</code>函数</li></ol><p>下面是我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> dict[<span class="number">21</span>][<span class="number">30</span>],ans[<span class="number">500</span>]; <span class="keyword">int</span> n,vis[<span class="number">21</span>],ans_max=<span class="number">0</span>,ans_temp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;dict[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;dict[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">///开头的字母</span></span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans_max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> word,<span class="keyword">int</span> pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pointer&lt;<span class="built_in">strlen</span>(dict[word]))&#123;</span><br><span class="line">        ans_temp++;</span><br><span class="line">        <span class="keyword">int</span> ans_mark=ans_temp;</span><br><span class="line">        ans_max=max(ans_max,ans_temp);</span><br><span class="line"></span><br><span class="line">        dfs(word,pointer+<span class="number">1</span>);<span class="comment">///这句话以上是将本单词中的下一个字母加入答案字符串中，以下是将查看以这个字母为基准，能不能接上其他单词的龙</span></span><br><span class="line"></span><br><span class="line">        ans_temp=ans_mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">///枚举n个词中哪个词的首字母可以和现在字符串的最后一个相同</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///!!!</span></span><br><span class="line">            m=pointer;</span><br><span class="line">            <span class="comment">///!!!其他人的做法是直接枚举单词 word 中的所有字母，不像我是通过 dfs(word,pointer+1)来枚举，所以不需要考虑pointer如何如何，我们这里如果对 pointer 后面的字母(pointer+1,pointer+2,...)一个个进行比对，必然会改变pointer的值，所以用了一个副本 m 进行比对，保证pointer值不变</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dict[word][m]==dict[i][j])&#123;<span class="comment">///如果头一个字母相同</span></span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(m&lt;<span class="built_in">strlen</span>(dict[word]))&#123;<span class="comment">///一直比对到最后一个字母，并且这里判断了“相邻的两部分不能存在包含关系”这一条件</span></span><br><span class="line">                    <span class="keyword">if</span>(dict[word][m]!=dict[i][j]) flag=<span class="literal">false</span>;</span><br><span class="line">                    m++; j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;<span class="comment">///如果每个字母都一样</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">///!!!</span></span><br><span class="line">                    <span class="keyword">int</span> ans_mark=ans_temp;<span class="comment">///记录一下现在的长度，因为再进行其他的dfs，ans_temp会被更新</span></span><br><span class="line">                    ans_temp+=j<span class="number">-1</span>;<span class="comment">///答案字符串的长度就可以加上新加入的单词的长度</span></span><br><span class="line">                    <span class="comment">///!!!注意这个地方这两句话应该是先记录 ans_temp 再更新 ans_temp ，因为我们最后回溯的时候是要回溯到没有接龙接上当前单词的状态，所以应该是先记录，后更新</span></span><br><span class="line"></span><br><span class="line">                    ans_max=max(ans_max,ans_temp);</span><br><span class="line">                    vis[i]--;</span><br><span class="line"></span><br><span class="line">                    dfs(i,j);</span><br><span class="line"></span><br><span class="line">                    vis[i]++;</span><br><span class="line">                    ans_temp=ans_mark;<span class="comment">///把ans_temp更新回来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>先预处理得到两两单词间的最短重合部分，然后搜索得到答案</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> dict[<span class="number">31</span>]; <span class="keyword">int</span> ans_now=<span class="number">1</span>,ans_max=<span class="number">0</span>,n,vis[<span class="number">31</span>],overlap[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">///这个地方把 ans_now 设为1，是因为第一个开头的字母不会被算在长度内，为了把这个开头的字母算进去，ans_now 从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_overlap</span><span class="params">(<span class="built_in">string</span>,<span class="built_in">string</span>)</span></span>;<span class="comment">///寻找两个单词的最小重合部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;dict[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;dict[<span class="number">0</span>];<span class="comment">///开头的字母</span></span><br><span class="line">    <span class="built_in">memset</span>(overlap,<span class="number">0</span>,<span class="keyword">sizeof</span>(overlap));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">        overlap[i][j]=find_overlap(dict[i],dict[j]);</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans_max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_overlap</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span><span class="comment">///其中，a是将要被别人接上去的字符串，b是想要接上去的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">///倒序寻找最小重合部分的大小</span></span><br><span class="line">        <span class="keyword">int</span> ja=i,jb=<span class="number">0</span>; <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(ja&lt;a.size())&#123;<span class="comment">///正序看看这个部分是否重合</span></span><br><span class="line">            <span class="keyword">if</span>(a[ja]!=b[jb]) &#123;flag=<span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            ja++; jb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans_overlap=a.size()-i; <span class="comment">///得到重叠部分的大小</span></span><br><span class="line">            <span class="keyword">if</span>(ans_overlap!=a.size()&amp;&amp;ans_overlap!=b.size()) <span class="keyword">return</span> ans_overlap; <span class="comment">///判断重叠部分是不是包含部分，如果不是就返回答案</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.size()==<span class="number">1</span>) <span class="keyword">return</span> ans_overlap; <span class="comment">///如果是开头的字母(cin&gt;&gt;dict[0])，永远有 ans_overlap==a.size()==0 那么不管ans_overlap!=a.size()是否成立，我们都要返回答案</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">///其他的情况下，重叠部分是包含部分，不能接龙，所以返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">///没找到重叠部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(overlap[word][i]&gt;<span class="number">0</span> &amp;&amp; vis[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            ans_now+=dict[i].size()-overlap[word][i];<span class="comment">///接上的字符串的长度</span></span><br><span class="line">            ans_max=max(ans_max,ans_now);</span><br><span class="line">            vis[i]--;</span><br><span class="line"></span><br><span class="line">            dfs(i);</span><br><span class="line"></span><br><span class="line">            vis[i]++;</span><br><span class="line">            ans_now-=dict[i].size()-overlap[word][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1019 单词接龙&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了…&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个程序一个问题就是循环根本就不会吧&lt;code&gt;dict&lt;/code&gt;全循环一遍，那可能就是初始化出了问题： &lt;code&gt;m=pointer&lt;/code&gt; 的位置，当时记得应该写一个副本 &lt;code&gt;m&lt;/code&gt; 代替 &lt;code&gt;pointer&lt;/code&gt; 被改变，但是写着写着忘了 &lt;code&gt;m&lt;/code&gt; 具体应该在哪被初始化了，问题就出现在这&lt;/li&gt;
&lt;li&gt;回溯的状态：一定要明确回溯应当回溯到具体那个状态，是&lt;code&gt;ans_temp&lt;/code&gt;已经被改变的状态吗？还是未改变的状态？本题中是&lt;code&gt;ans_temp&lt;/code&gt;未改变的状态&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P1101 单词方阵</title>
    <link href="http://yoursite.com/2019/06/17/P1101%20%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5/"/>
    <id>http://yoursite.com/2019/06/17/P1101 单词方阵/</id>
    <published>2019-06-16T16:00:00.000Z</published>
    <updated>2019-06-27T12:38:11.330Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P1101" target="_blank" rel="noopener">洛谷P1101 单词方阵</a></p><hr><p><code>dir</code> 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个<code>dir[i]</code>来判定哪一个方向符合条件就行了<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> matrix[<span class="number">103</span>][<span class="number">103</span>], yizhong[<span class="number">8</span>]=<span class="string">"yizhong"</span>; <span class="keyword">bool</span> mark[<span class="number">103</span>][<span class="number">103</span>];</span><br><span class="line"><span class="comment">/// matrix 存储每个位置的字母，yizhong 存储我们要找的字符串 "yizhong"，mark存储这个位置符不符合要求，最后要不要被变成 "*" 输出</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/// dir[8] 存储了8个方向，dir[i][0] 是x轴坐标，dir[i][1] 是y轴坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">/// 这个题虽然放在dfs里面但是因为这个字符串的方向是固定的，不会拐弯抹角，所以好像和dfs没什么关系</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">cin</span>&gt;&gt;matrix[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dfs(i,j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mark[i][j]) <span class="built_in">cout</span>&lt;&lt;matrix[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123; <span class="comment">///对于任意一个点，我们都看看它周围八个方向各自符不符合条件</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;<span class="number">7</span>)&#123; <span class="comment">///分别检视每一个字符 与 yizhong 是否匹配</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[x+j*dir[i][<span class="number">0</span>]][y+j*dir[i][<span class="number">1</span>]] != yizhong[j])&#123; <span class="comment">///非常精髓</span></span><br><span class="line">                flag=<span class="literal">false</span>; <span class="keyword">break</span>; <span class="comment">/// 不匹配，flag=false</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123; <span class="comment">///匹配的话就记录下来它们是符合要求的，最后直接输出当前位置的字符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)</span><br><span class="line">                mark[x+j*dir[i][<span class="number">0</span>]][y+j*dir[i][<span class="number">1</span>]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1101 单词方阵&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个&lt;code&gt;dir[i]&lt;/code&gt;来判定哪一个方向符合条件就行了
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P1219 八皇后</title>
    <link href="http://yoursite.com/2019/06/16/P1219%20%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <id>http://yoursite.com/2019/06/16/P1219 八皇后/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-27T12:35:50.676Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P1219" target="_blank" rel="noopener">洛谷P1219 八皇后</a></p><hr><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>自己的程序出现的几个问题：</p><ol><li>对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的</li><li>不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子<a id="more"></a></li><li>注意初始化的部分，一开始就是把循环语句里写成了 <code>NE_SW[i]=true; NE_SW[i+1]=true</code> 导致了错误而且一直没检查出来</li><li>最后那个存储 <code>solution</code> 的地方还是有问题，如果找到了某一行的一个解并且继续向下搜寻这一行的其他解的话，会出现不存储前面几行棋子位置的问题，没想到解决方法只能在输出的地方做了些操作</li><li>大部分标解中<code>dfs</code>只有一个参数就是行数<code>x</code>然后对于每个<code>x</code>进行<code>for</code>循环枚举纵坐标<code>y</code>，我这样的做法也可以</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> board[<span class="number">14</span>][<span class="number">14</span>],col[<span class="number">14</span>],line[<span class="number">14</span>],NE_SW[<span class="number">26</span>],NW_SE[<span class="number">26</span>]; <span class="keyword">int</span> n,ans,solution[<span class="number">3</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flag</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;col[i]=<span class="literal">true</span>; line[i]=<span class="literal">true</span>; NE_SW[i]=<span class="literal">true</span>; NW_SE[i]=<span class="literal">true</span>; NE_SW[i+n]=<span class="literal">true</span>; NW_SE[i+n]=<span class="literal">true</span>;&#125;<span class="comment">/// 这个地方初始化一定要注意</span></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(solution[i][j]==<span class="number">0</span>) solution[i][j]=solution[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;solution[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flag</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">///判定这个点能不能放棋子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[x]&amp;&amp;line[y])&#123;<span class="keyword">if</span>(NE_SW[x+y<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>( y&lt;=x &amp;&amp; NW_SE[n-<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))] ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( y&gt;x &amp;&amp; NW_SE[n+<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))] ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"最后一个对角线出了问题"&lt;&lt;endl;</span></span><br><span class="line">    &#125;<span class="comment">//cout&lt;&lt;"第一个对角线出了问题"&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"x,y有问题"&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///cout&lt;&lt;"function called at"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(flag(x,y))&#123;</span><br><span class="line">        <span class="comment">//if(x==n) ans++;</span></span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=<span class="number">3</span>) solution[ans][x]=y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///cout&lt;&lt;endl&lt;&lt;"one unit placed at"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">        col[x]=<span class="literal">false</span>;</span><br><span class="line">        line[y]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;=<span class="number">7</span>-x) NE_SW[x+y<span class="number">-1</span>]=<span class="literal">false</span>; <span class="comment">///左上角部分的 右上-左下对角线</span></span><br><span class="line">            <span class="keyword">else</span> NE_SW[x+y<span class="number">-1</span>]=<span class="literal">false</span>; <span class="comment">/// 右下角部分的 右上-左下对角线</span></span><br><span class="line">        <span class="keyword">if</span>(y&lt;=x) NW_SE[n-<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))]=<span class="literal">false</span>; <span class="comment">///右上角部分的 左上-右下对角线</span></span><br><span class="line">            <span class="keyword">else</span> NW_SE[n+<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))]=<span class="literal">false</span>; <span class="comment">///左下角部分 左上-右下对角线</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x==n) &#123;ans++;&#125; <span class="comment">///cout&lt;&lt;"-------------"&lt;&lt;endl&lt;&lt;"one solution found, total solution is now "&lt;&lt;ans&lt;&lt;endl&lt;&lt;"-------------"&lt;&lt;endl;&#125;</span></span><br><span class="line">        <span class="keyword">else</span> dfs(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        col[x]=<span class="literal">true</span>;</span><br><span class="line">        line[y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;=<span class="number">7</span>-x) NE_SW[x+y<span class="number">-1</span>]=<span class="literal">true</span>; <span class="comment">///左上角部分的 右上-左下对角线</span></span><br><span class="line">            <span class="keyword">else</span> NE_SW[x+y<span class="number">-1</span>]=<span class="literal">true</span>; <span class="comment">/// 右下角部分的 右上-左下对角线</span></span><br><span class="line">        <span class="keyword">if</span>(y&lt;=x) NW_SE[n-<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))]=<span class="literal">true</span>; <span class="comment">///右上角部分的 左上-右下对角线</span></span><br><span class="line">            <span class="keyword">else</span> NW_SE[n+<span class="keyword">int</span>(<span class="built_in">abs</span>(x-y))]=<span class="literal">true</span>; <span class="comment">///左下角部分 左上-右下对角线</span></span><br><span class="line">        <span class="comment">///cout&lt;&lt;"value changed back at"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y&lt;n) dfs(x,y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更可读的代码以及问题优化"><a href="#更可读的代码以及问题优化" class="headerlink" title="更可读的代码以及问题优化"></a>更可读的代码以及问题优化</h2><ol><li>优化了对角线的表达</li><li>优化了答案位置的记录</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> col[<span class="number">14</span>],line[<span class="number">14</span>],NE_SW[<span class="number">26</span>],NW_SE[<span class="number">26</span>]; <span class="keyword">int</span> n,ans=<span class="number">0</span>,solution[<span class="number">14</span>]; <span class="comment">/// col[x] line[y]</span></span><br><span class="line"><span class="comment">/// NE_SW 右上向左下方向的对角线，从左上角(1,1)为第一条，第二条是(2,1)-(1,2)</span></span><br><span class="line"><span class="comment">/// NW_SE 左上到右下方向的对角线，从右上角(1,n)为第一条，第二条是(n-1,1)-(n,2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flag</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;col[i]=<span class="literal">true</span>; line[i]=<span class="literal">true</span>; NE_SW[i]=<span class="literal">true</span>; NW_SE[i]=<span class="literal">true</span>; NE_SW[i+n]=<span class="literal">true</span>; NW_SE[i+n]=<span class="literal">true</span>;&#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flag</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> col[x]&amp;&amp;line[y]&amp;&amp;NE_SW[x+y]&amp;&amp;NW_SE[n+y-x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag(x,y))&#123;</span><br><span class="line">        solution[x]=y;<span class="comment">///注意这个地方特别精髓，因为如果我们每个答案都开新的一行数组记录的话有可能会出现上面问题4说的情况，所以我们只需要每次覆盖记录就好了，反正x永远是按从上到下的顺序来的</span></span><br><span class="line">        <span class="comment">//col[x]=false; line[y]=false; NE_SW[x+y]=false; NW_SE[n+y-x]=false;</span></span><br><span class="line">        col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x];</span><br><span class="line">        <span class="comment">///注意 !col[x] 只是表达 col[x] 取反的一个值，只有 col[x]=!col[x] 才能给原波尔值赋值为它的反</span></span><br><span class="line">        <span class="keyword">if</span>(x==n)&#123;<span class="comment">///最后一行也被填好了，我们得到一个解</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;solution[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dfs(x+<span class="number">1</span>,<span class="number">1</span>);<span class="comment">///还不到最后一行的话就接着去找下一行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///回溯：拿走刚刚放下的棋子</span></span><br><span class="line">        <span class="comment">//col[x]=true; line[y]=true; NE_SW[x+y]=true; NW_SE[n+y-x]=true;</span></span><br><span class="line">        col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///如果这个位置不符合条件(flag(x,y)==false)/这个位置符合条件的情况已经被全部枚举了(flag(x,y)==true) 那么我们就可以去找本行的下一个位置是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span>(y&lt;n) dfs(x,y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1219&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1219 八皇后&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;我的解法&quot;&gt;&lt;a href=&quot;#我的解法&quot; class=&quot;headerlink&quot; title=&quot;我的解法&quot;&gt;&lt;/a&gt;我的解法&lt;/h2&gt;&lt;p&gt;自己的程序出现的几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的&lt;/li&gt;
&lt;li&gt;不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P1031 均分纸牌</title>
    <link href="http://yoursite.com/2019/06/04/P1031%20%E5%9D%87%E5%88%86%E7%BA%B8%E7%89%8C/"/>
    <id>http://yoursite.com/2019/06/04/P1031 均分纸牌/</id>
    <published>2019-06-03T16:00:00.000Z</published>
    <updated>2019-06-27T12:40:49.788Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P1031" target="_blank" rel="noopener">洛谷P1031 均分纸牌</a></p><hr><h2 id="标解"><a href="#标解" class="headerlink" title="标解"></a>标解</h2><p><strong>注意本题中平均数的运用</strong></p><p>首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。<a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a,p=<span class="number">0</span>,js=<span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt;a;<span class="keyword">int</span> q[a];  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;a;y++)&#123;<span class="built_in">cin</span> &gt;&gt;q[y]; p+=q[y];&#125; p/=a;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;a;y++)q[y]-=p;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;a;y++) &#123;<span class="keyword">if</span> (q[y]==<span class="number">0</span>)<span class="keyword">continue</span>; q[y+<span class="number">1</span>]+=q[y]; js++; &#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;js;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,card[<span class="number">103</span>],num,mean,no_count=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) &#123;<span class="built_in">cin</span>&gt;&gt;card[i]; sum+=card[i];&#125;</span><br><span class="line">    mean=sum/num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pointer=<span class="number">0</span>,local_sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        local_sum+=card[i];</span><br><span class="line">        pointer++;<span class="comment">///我的思路是记录有没有一个 local_max==local_sum，如果有 local_sum，即pointer所指的那一堆，之前的就全部排好了，不需要再操心了</span></span><br><span class="line">        <span class="keyword">if</span>(pointer==<span class="number">1</span> &amp;&amp; card[i]==mean) &#123;pointer=<span class="number">1</span>; no_count++;&#125;</span><br><span class="line">        <span class="comment">///直接等于平均数的堆要拿出来特殊讨论，因为他们只有跟在已经排好序的堆后面的时候才不需要再经过一次移动，而前面的堆已经排好序的标志就是 pointer==1，这种情况下我们可以少移动一个，并且重新设置 pointer==1 代表前面的堆都有序</span></span><br><span class="line">        <span class="keyword">if</span>(local_sum==pointer*mean &amp;&amp; pointer!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">/// local_sum==pointer*mean 此时我们找到一个堆，可以使前面的所有堆获得符合要求的解，并且他只需要向别人输送牌，自己不需要接受，所以有一个 no_count++</span></span><br><span class="line">            <span class="comment">/// pointer!=1 这是 local_sum 就是他本身，必然相等</span></span><br><span class="line">            no_count++;</span><br><span class="line">            pointer=<span class="number">0</span>;</span><br><span class="line">            local_sum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num-no_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1031&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1031 均分纸牌&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;标解&quot;&gt;&lt;a href=&quot;#标解&quot; class=&quot;headerlink&quot; title=&quot;标解&quot;&gt;&lt;/a&gt;标解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意本题中平均数的运用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P2678 跳石头</title>
    <link href="http://yoursite.com/2019/06/03/P2678%20%E8%B7%B3%E7%9F%B3%E5%A4%B4/"/>
    <id>http://yoursite.com/2019/06/03/P2678 跳石头/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-06-27T12:27:21.150Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P2678" target="_blank" rel="noopener">洛谷P2678 跳石头</a></p><hr><p>这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 <strong>贪心+二分查找</strong> 的方法来做</p><h2 id="二分答案-二分查找"><a href="#二分答案-二分查找" class="headerlink" title="二分答案/二分查找"></a>二分答案/二分查找</h2><p>有序（单调）的，有界的就可以用二分法查找。<a id="more"></a></p><ol><li><p><strong>有界：</strong>对于本题，我们可以发现，这个所谓的最短跳跃距离显然不能超过一个范围（跳一次从头跳到尾）。也就是说，答案是有一个确定的范围限制的（开头到结尾的距离内），我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行，这实际上是一种倒推</p></li><li><p><strong>二分：</strong>那么如何确保我们可以最快的找到答案呢？二分是最好选择</p></li><li><p><strong>单调：</strong>二分的前提条件是什么？是答案区间是整体有序的。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。最优解一定可行，但可行解不一定最优。</p><ul><li><p>我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x’(x’&lt;x)都是可行解。</p></li><li><p>并且，如果有一个数y是非法解，那么一般的，所有的y’(y’&gt;y)都是非法解。</p></li></ul></li></ol><p>总结来说，可以使用二分查找的条件：解的上下界确定(l=0,r=L),可以写出判断条件(f(x)&lt;=m),解具有区间单调性(在某个值之前条件都成立，之后都不成立)</p><p><del>本题和 P2855 <a href="https://www.luogu.org/problemnew/show/P2855" target="_blank" rel="noopener">River Hopscotch</a> 是同一道题</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> rocks[<span class="number">50003</span>],ending,num,removed,result;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finding</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ending&gt;&gt;num&gt;&gt;removed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="built_in">cin</span>&gt;&gt;rocks[i];</span><br><span class="line">    rocks[<span class="number">0</span>]=<span class="number">0</span>; rocks[num+<span class="number">1</span>]=ending;</span><br><span class="line">    sort(rocks+<span class="number">1</span>,rocks+num+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    finding(<span class="number">0</span>,ending);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finding</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)/<span class="number">2</span>, removing=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,pointer=<span class="number">0</span>;<span class="comment">///now 表示我们现在所在的位置，pointer 表示下一个可以跳到的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pointer&lt;num)&#123;<span class="comment">///人家这个方法直接一步子迈过去了，根本不需要记录哪个石头被拿掉了，或者判定一个原本有石头的地方被没被拿掉，毕竟题目本身就叫跳石头，为什么要一个个石头看呢，直接跳不就好了</span></span><br><span class="line">        pointer++;</span><br><span class="line">        <span class="keyword">if</span>(rocks[pointer]-rocks[now]&lt;mid)<span class="comment">///我们认为mid是最短跳跃距离，如果有某种情况使得跳跃距离比这个最短的还短，我们就需要拿走这块石头来增大这个地方的跳跃距离，使其大于最短跳跃距离</span></span><br><span class="line">            removing++;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果比最短距离长的话，我们就可以跳过去</span></span><br><span class="line">            now=pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)&#123;</span><br><span class="line">        <span class="comment">///这个地方我写 m&lt;n 或者 m&lt;=n 有区别吗？我的m到最后的时候只能通过mid+1这一种方式更新，+1又不影响/2以后mid的值，所以这两个判定不是一样的吗？</span></span><br><span class="line">        <span class="comment">///确实判定的时候没什么区别，最后都会更新到m=4 n=4 mid=4，但是 m&lt;n 运行到 m=4 n=4 mid=4 会发现 m!&lt;n 所以不会更新 result</span></span><br><span class="line">        <span class="keyword">if</span>(removing&gt;removed) finding(m,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">///如果我们以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案是不合法的，并且所有大于mid的都不合法（越大于mid移动的石块只会越来越多），所以减少 最小移动距离 使得我们不要移动那么多石块</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(removing&lt;=removed) &#123; result=mid; finding(mid+<span class="number">1</span>,n);&#125;</span><br><span class="line">        <span class="comment">///如果以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案合法，但是因为我们要寻找最大的最小值，所以增大 最小距离 看看有没有更优的解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">25 5 2 </span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">14</span></span><br><span class="line"><span class="comment">17 </span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h2><p>非递归形式的二分查找模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=ll;<span class="comment">/// 1 是答案的最小值，ll是答案的最大值 </span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123; <span class="comment">///当左右边界重合的时候就是答案，退出循环 </span></span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,q=check(mid);<span class="comment">//“&gt;&gt;1”相当于“/2” </span></span><br><span class="line"><span class="keyword">if</span>(check) <span class="comment">///当该距离满足条件的时候 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///去寻找右半部分，看看还有没有符合条件的更大的值</span></span><br><span class="line">        ll=mid+<span class="number">1</span>;<span class="comment">///ll上mid右边，找右半部分 </span></span><br><span class="line">        ans=mid;<span class="comment">///记录答案（更新中） </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        l=mid+<span class="number">1</span>;<span class="comment">///若这个值不满足，就找左部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个二分查找的样例</p><h3 id="P1824-Aggressive-Cows"><a href="#P1824-Aggressive-Cows" class="headerlink" title="P1824 Aggressive Cows"></a>P1824 <a href="https://www.luogu.org/problemnew/show/P1824" target="_blank" rel="noopener">Aggressive Cows</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> stall[<span class="number">100005</span>],cow_num,stall_num,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finding</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;stall_num&gt;&gt;cow_num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=stall_num;i++) <span class="built_in">cin</span>&gt;&gt;stall[i];</span><br><span class="line">    sort(stall+<span class="number">1</span>,stall+stall_num+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    finding(<span class="number">1</span>,stall[stall_num]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finding</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span><span class="comment">//看到一个符合要求的就填进去，最后看填进去的cow和一共有的是多是少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(m+n)/<span class="number">2</span>,now=<span class="number">1</span>,pointer=<span class="number">1</span>,cow_mid=<span class="number">1</span>;<span class="comment">///cow_mid 从1开始，如果从0开始实际上算的是间距，n+1才是牛的数量</span></span><br><span class="line">    <span class="keyword">while</span>(pointer&lt;stall_num)&#123;</span><br><span class="line">        pointer++;</span><br><span class="line">        <span class="keyword">if</span>(stall[pointer]-stall[now]&gt;=mid)&#123;<span class="comment">///这里注意是 &gt;= 只要比最短的距离(mid)大，我们就可以放一头奶牛在这里</span></span><br><span class="line">            cow_mid++; now=pointer;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cow_mid&gt;=cow_num) &#123;ans=mid; finding(mid+<span class="number">1</span>,n);&#125; <span class="comment">///如果这次放的比我们需要放的多，说明我们的最短间距太小了，所以要增大最短间距</span></span><br><span class="line">        <span class="keyword">else</span> finding(m,mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2678&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P2678 跳石头&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 &lt;strong&gt;贪心+二分查找&lt;/strong&gt; 的方法来做&lt;/p&gt;
&lt;h2 id=&quot;二分答案-二分查找&quot;&gt;&lt;a href=&quot;#二分答案-二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分答案/二分查找&quot;&gt;&lt;/a&gt;二分答案/二分查找&lt;/h2&gt;&lt;p&gt;有序（单调）的，有界的就可以用二分法查找。
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P1090 合并果子</title>
    <link href="http://yoursite.com/2019/05/30/P1090%20%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/"/>
    <id>http://yoursite.com/2019/05/30/P1090 合并果子/</id>
    <published>2019-05-29T16:00:00.000Z</published>
    <updated>2019-06-27T12:31:58.850Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源： <a href="https://www.luogu.org/problemnew/show/P1090" target="_blank" rel="noopener">洛谷P1090 合并果子</a></p><hr><h2 id="一维数组做法"><a href="#一维数组做法" class="headerlink" title="一维数组做法"></a>一维数组做法</h2><p>本题是一个简单的 <a href="https://www.cnblogs.com/kubixuesheng/p/4397798.html" target="_blank" rel="noopener">Huffman树</a>。Huffman编码 在 UTF-8 &amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度</p><p>这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快</p><a id="more"></a><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,berry[<span class="number">10005</span>];<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;berry[i];</span><br><span class="line"></span><br><span class="line">    sort(berry+<span class="number">1</span>,berry+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        berry[i+<span class="number">1</span>]=berry[i]+berry[i+<span class="number">1</span>];<span class="comment">///计算每个果堆的重量</span></span><br><span class="line">        ans+=berry[i+<span class="number">1</span>];<span class="comment">///答案是每次搬的果堆的重量之和</span></span><br><span class="line">        <span class="keyword">if</span>(berry[i+<span class="number">1</span>]&gt;berry[i+<span class="number">2</span>])&#123;<span class="comment">///解决前两个数之和大于第三/四个数的情况（比如有 1 1 1 1）最优解为4而不是7</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(berry[j]&gt;berry[j+<span class="number">1</span>]) swap(berry[j],berry[j+<span class="number">1</span>]);<span class="comment">///线性排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并做法"><a href="#归并做法" class="headerlink" title="归并做法"></a><a href="https://www.luogu.org/blog/user52918/solution-p1090" target="_blank" rel="noopener">归并做法</a></h2><blockquote><p>据说是离散化算法 就是先把原本的从小到大排序排好。然后用两个队列，一个是存储原本的，另一个是存储合成的（由于原本的是从小到大所有新开的也是从小到大）。然后在两个队列的头取最小的，执行两次然后把这两个合并加入第二个队列中。 然后由于输入： (1≤ai≤20000)(1≤ai≤20000)(1≤ai≤20000) ，所以用桶排序就可以 O(n)O(n)O(n) 时间复杂度</p></blockquote><p>要义是储存原本果堆的<em>a1</em>是按顺序排列的，所以存储两两合成的新果堆的<em>a2</em>也是按顺序排列的。取这两个果堆序列中最小的两个果堆，必定获得这一步能获得的最小的果堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k,x,num,n1,n2,a1[<span class="number">30001</span>],a2[<span class="number">30001</span>],t[<span class="number">20001</span>],w,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">    <span class="built_in">memset</span>(a1,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(a1));</span><br><span class="line">    <span class="built_in">memset</span>(a2,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(a2));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        t[x]++;<span class="comment">//桶</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (t[i])<span class="comment">//通排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            t[i]--;</span><br><span class="line">            a1[++n1]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k&lt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i]&lt;a2[j])<span class="comment">//取最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            w=a1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            w=a2[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a1[i]&lt;a2[j])<span class="comment">//取第二次</span></span><br><span class="line">        &#123;</span><br><span class="line">            w+=a1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            w+=a2[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        a2[++n2]=w;<span class="comment">//加入第二个队列</span></span><br><span class="line">        k++;<span class="comment">//计算合并次数</span></span><br><span class="line">        sum+=w;<span class="comment">//计算价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉（小根）堆"><a href="#二叉（小根）堆" class="headerlink" title="二叉（小根）堆"></a><a href="https://www.luogu.org/blog/user9156/yi-fen-lai-zi-di-shou-xie-er-cha-dui" target="_blank" rel="noopener">二叉（小根）堆</a></h2><p><em>s</em> 代表 <em>son</em>, <em>p</em> 代表 <em>parent</em>, <em>size</em> 代表整个<a href="https://www.cnblogs.com/wangchaowei/p/8288216.html" target="_blank" rel="noopener">二叉堆</a>中存储的数据数量</p><blockquote><p><a href="https://blog.csdn.net/qq_22642239/article/details/80774013" target="_blank" rel="noopener">完美二叉树, 完全二叉树和完满二叉树的区分</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,heap[maxn],size=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//二叉小根堆向上调整（子节点小于父节点就调整）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(p&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(heap[p]&lt;heap[p/<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">      swap(heap[p],heap[p/<span class="number">2</span>]);</span><br><span class="line">      p/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="comment">//二叉堆插入，新元素放在堆底，向上调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  heap[++size]=val;</span><br><span class="line">  up(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//二叉小根堆向下调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s=p*<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(s&lt;=size)</span><br><span class="line">  &#123; <span class="comment">//下面这句话是从左右儿子中选一个更小的做交换</span></span><br><span class="line">    <span class="keyword">if</span>(s&lt;size&amp;&amp;heap[s+<span class="number">1</span>]&lt;heap[s]) s++; </span><br><span class="line">    <span class="keyword">if</span>(heap[s]&lt;heap[p])</span><br><span class="line">    &#123;</span><br><span class="line">      swap(heap[s],heap[p]);</span><br><span class="line">      p=s; s=p*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">()</span> <span class="comment">//二叉堆删除堆顶</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  heap[<span class="number">1</span>]=heap[size--]; <span class="comment">//将堆底移至堆顶，向下调整</span></span><br><span class="line">  down(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettop</span><span class="params">()</span> <span class="comment">//返回堆顶的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    insert(a); <span class="comment">//建立二叉堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="comment">//其实这里不会越界，但好像原题数据是3万</span></span><br><span class="line">  <span class="keyword">while</span>(size&gt;=<span class="number">2</span>) <span class="comment">//如果还可合并</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> top1=gettop(); <span class="comment">//取出堆顶（堆中最小值）后删除堆顶</span></span><br><span class="line">    extract();</span><br><span class="line">    <span class="keyword">int</span> top2=gettop(); <span class="comment">//同上</span></span><br><span class="line">    extract();</span><br><span class="line">    ans+=(top1+top2);</span><br><span class="line">    insert(top1+top2); <span class="comment">//将两数之和加入二叉堆，重复运算</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出答案</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源： &lt;a href=&quot;https://www.luogu.org/problemnew/show/P1090&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1090 合并果子&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一维数组做法&quot;&gt;&lt;a href=&quot;#一维数组做法&quot; class=&quot;headerlink&quot; title=&quot;一维数组做法&quot;&gt;&lt;/a&gt;一维数组做法&lt;/h2&gt;&lt;p&gt;本题是一个简单的 &lt;a href=&quot;https://www.cnblogs.com/kubixuesheng/p/4397798.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Huffman树&lt;/a&gt;。Huffman编码 在 UTF-8 &amp;amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度&lt;/p&gt;
&lt;p&gt;这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快&lt;/p&gt;
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>P1309 瑞士轮</title>
    <link href="http://yoursite.com/2019/05/30/P1309%20%E7%91%9E%E5%A3%AB%E8%BD%AE/"/>
    <id>http://yoursite.com/2019/05/30/P1309 瑞士轮/</id>
    <published>2019-05-29T16:00:00.000Z</published>
    <updated>2019-06-27T12:26:55.045Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://www.luogu.org/problemnew/show/P1309" target="_blank" rel="noopener">洛谷P1309 瑞士轮</a></p><hr><ol><li>胜者组和败者组分别是有序的，使用 <em>mergesort</em> 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 <em>quicksort</em>，则默认整个数据是无序的，对每个数据都重新排序所以会超时 <a id="more"></a></li><li>一种可以替代结构体的方法：排名的时候我们可以只对每个选手的序号进行排序，这样做既可以保证我们有各个人的排序，又可以保证他们的成绩和实力得到记录（序号对应着成绩和实力，在对序号根据实力排序的同时，每个序号对应的成绩和实力的顺序是不变的）</li><li>*<a href="https://blog.csdn.net/vanturman/article/details/81706538" target="_blank" rel="noopener">sort</a>* 函数中 *<a href="https://blog.csdn.net/diyinqian/article/details/72904404" target="_blank" rel="noopener">cmp</a>* 的使用方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num,round,inquiry,score[<span class="number">200005</span>],power[<span class="number">200005</span>],No[<span class="number">200005</span>],winner[<span class="number">100005</span>],loser[<span class="number">100005</span>];</span><br><span class="line"><span class="comment">///其中，No里每个下标代表选手的排名，power &amp; score 的下标代表选手的序号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num&gt;&gt;round&gt;&gt;inquiry;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i++) <span class="built_in">cin</span>&gt;&gt;score[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i++) <span class="built_in">cin</span>&gt;&gt;power[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i++) No[i]=i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;" "&lt;&lt;score[i]&lt;&lt;endl;</span></span><br><span class="line">    sort(No+<span class="number">1</span>,No+<span class="number">1</span>+<span class="number">2</span>*num,cmp);</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;" "&lt;&lt;score[i]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=round;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        compete();</span><br><span class="line">        mergesort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;No[inquiry];</span><br><span class="line">    <span class="comment">//while(true);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///cmp函数使用范例</span></span><br><span class="line">    <span class="keyword">if</span>(score[m]==score[n]) <span class="keyword">return</span> m&lt;n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> score[m]&gt;score[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i=i+<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(power[No[i]]&gt;power[No[i+<span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            score[No[i]]++;</span><br><span class="line">            winner[i/<span class="number">2</span>+<span class="number">1</span>]=No[i];</span><br><span class="line">            loser[i/<span class="number">2</span>+<span class="number">1</span>]=No[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(power[No[i]]&lt;power[No[i+<span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            score[No[i+<span class="number">1</span>]]++;</span><br><span class="line">            winner[i/<span class="number">2</span>+<span class="number">1</span>]=No[i+<span class="number">1</span>];</span><br><span class="line">            loser[i/<span class="number">2</span>+<span class="number">1</span>]=No[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*cout&lt;&lt;"compete"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=num;i++) cout&lt;&lt;winner[i]&lt;&lt;" "&lt;&lt;loser[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=num &amp;&amp; j&lt;=num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if(score[winner[i]]&gt;score[loser[j]])</span></span><br><span class="line">        <span class="keyword">if</span>(cmp(winner[i],loser[j])) <span class="comment">///完全无法理解这个地方只写一个cmp是怎么过的，难道不会有位于后面的相等score项实际比前面的相等score项序号更小这种情况吗</span></span><br><span class="line">        &#123;</span><br><span class="line">            No[i+j<span class="number">-1</span>]=winner[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else if(score[loser[j]]&gt;score[winner[i]])</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            No[i+j<span class="number">-1</span>]=loser[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*else if(score[loser[j]]==score[winner[i]])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int k=0,temp[200005];</span></span><br><span class="line"><span class="comment">            while(score[winner[i]]==score[winner[i+1]]) temp[++k]=winner[i++];</span></span><br><span class="line"><span class="comment">            while(score[loser[j]]==score[loser[j]]) temp[++k]=loser[j++];</span></span><br><span class="line"><span class="comment">            sort(temp,temp+k);</span></span><br><span class="line"><span class="comment">            for(int a=1;a&lt;=k;a++) No[a+i+j-1]=temp[a];</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=num)</span><br><span class="line">    &#123;</span><br><span class="line">        No[i+num]=winner[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=num)</span><br><span class="line">    &#123;</span><br><span class="line">        No[j+num]=loser[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*cout&lt;&lt;"mergesort";</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=num*2;i++) cout&lt;&lt;No[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">7 6 6 7</span></span><br><span class="line"><span class="comment">10 5 20 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来源：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1309&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1309 瑞士轮&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;胜者组和败者组分别是有序的，使用 &lt;em&gt;mergesort&lt;/em&gt; 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 &lt;em&gt;quicksort&lt;/em&gt;，则默认整个数据是无序的，对每个数据都重新排序所以会超时
    
    </summary>
    
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Git Command</title>
    <link href="http://yoursite.com/2019/02/10/Intro-to-Git-Command/"/>
    <id>http://yoursite.com/2019/02/10/Intro-to-Git-Command/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-06-27T02:35:37.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Creating-repository"><a href="#Creating-repository" class="headerlink" title="Creating repository"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="noopener">Creating repository</a></h2><ul><li><code>git init</code>: creat a repository</li><li><code>git add File_Name</code>: add “File_Name” to repository</li><li><code>git add .</code> : add all files </li><li><code>git commit -m &quot;message&quot;</code>: commit changes and tell others what changes have been made </li></ul><a id="more"></a><hr><h2 id="Way-back-Machine"><a href="#Way-back-Machine" class="headerlink" title="Way-back Machine"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000" target="_blank" rel="noopener">Way-back Machine</a></h2><ul><li><code>git status</code>: tell you which files have been changed </li><li><code>git diff</code>: check what content exactly has been changed in each file</li></ul><h3 id="Time-Travelling"><a href="#Time-Travelling" class="headerlink" title="Time Travelling"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">Time Travelling</a></h3><ul><li><p>commitID: git uses commit ID, a hex number calculated by SHA1 to record your commit history</p></li><li><p>HEAD: HEAD is the current version, HEAD^ is the previous, HEAD^^ is the one before the previous, HEAD~100 is the last 100.</p></li><li><p><code>git log</code>: check the commit history</p></li><li><p><code>git reflog</code>: check the command history</p></li><li><p><code>git reset --hard CommitID</code> : Going back to the “Commit ID” version</p><p>(e.g. <code>git reset --hard HEAD^</code> : going back to the previous version)</p></li><li><p>When you go back, the “future version” will no longer appear in “<code>git log</code>“. However, you can use “<code>git reflog</code>“ to trace “commit ID” from the future</p></li></ul><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt="Working Directory and Repository"></p><h3 id="Undo-Changes"><a href="#Undo-Changes" class="headerlink" title="Undo Changes"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000" target="_blank" rel="noopener">Undo Changes</a></h3><ol><li><p>messed up with working directory: use <code>git checkout -- File_Name</code> to discard changes in working directory and make “File_Name” to go back to the latest “committed” or “added” version</p></li><li><p>messed up with working directory and added it to stage: use <code>git reset HEAD File_Name</code> to discard changes in stage but keep “File_Name” in working directory changed, therefore going back to situation 1</p></li><li><p>committed the mess to master branch: use the <em>Time Traveling</em> technique in the previous section</p></li></ol><h3 id="Deleting-Files"><a href="#Deleting-Files" class="headerlink" title="Deleting Files"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758392816224cafd33c44b4451887cc941e6716805c000" target="_blank" rel="noopener">Deleting Files</a></h3><p>If you want to delete files that are already committed to the master branch:</p><ol><li>delete the file in working directory: <code>rm File_Name</code></li><li>delete the file from git / restore the file<ol><li>delete the file from git: <code>git rm File_Name</code> &amp; <code>git commit</code></li><li>restore the file: <code>git checkout -- File_Name</code></li></ol></li></ol><hr><h2 id="Managing-Branch"><a href="#Managing-Branch" class="headerlink" title="Managing Branch"></a>Managing Branch</h2><h3 id="Creating-and-Deleting-Branch"><a href="#Creating-and-Deleting-Branch" class="headerlink" title="Creating and Deleting Branch"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">Creating and Deleting Branch</a></h3><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git checkout &lt;name&gt;</code></li><li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code></li></ul><h3 id="Solving-Conflicts"><a href="#Solving-Conflicts" class="headerlink" title="Solving Conflicts"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000" target="_blank" rel="noopener">Solving Conflicts</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Creating-repository&quot;&gt;&lt;a href=&quot;#Creating-repository&quot; class=&quot;headerlink&quot; title=&quot;Creating repository&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating repository&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;: creat a repository&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add File_Name&lt;/code&gt;: add “File_Name” to repository&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt; : add all files &lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;message&amp;quot;&lt;/code&gt;: commit changes and tell others what changes have been made &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/02/09/hello-world/"/>
    <id>http://yoursite.com/2019/02/09/hello-world/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-06-26T15:29:59.539Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
